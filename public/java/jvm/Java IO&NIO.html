<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>Java IO/NIO | 一兜小白菜</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/learning_blog/logo.png">
    <meta name="description" content="learning something">
    <link rel="preload" href="/learning_blog/assets/css/0.styles.292e88f6.css" as="style"><link rel="preload" href="/learning_blog/assets/js/app.a4dcdc72.js" as="script"><link rel="preload" href="/learning_blog/assets/js/2.15fb6e89.js" as="script"><link rel="preload" href="/learning_blog/assets/js/17.5e4e5795.js" as="script"><link rel="prefetch" href="/learning_blog/assets/js/10.625d3583.js"><link rel="prefetch" href="/learning_blog/assets/js/11.39b55b78.js"><link rel="prefetch" href="/learning_blog/assets/js/12.8c71ddec.js"><link rel="prefetch" href="/learning_blog/assets/js/13.dcfb532c.js"><link rel="prefetch" href="/learning_blog/assets/js/14.3a208a6d.js"><link rel="prefetch" href="/learning_blog/assets/js/15.c1827914.js"><link rel="prefetch" href="/learning_blog/assets/js/16.c19fb499.js"><link rel="prefetch" href="/learning_blog/assets/js/18.46608703.js"><link rel="prefetch" href="/learning_blog/assets/js/19.5100b952.js"><link rel="prefetch" href="/learning_blog/assets/js/20.79a98d11.js"><link rel="prefetch" href="/learning_blog/assets/js/21.bb14ac69.js"><link rel="prefetch" href="/learning_blog/assets/js/22.78e0dbe7.js"><link rel="prefetch" href="/learning_blog/assets/js/23.86119b81.js"><link rel="prefetch" href="/learning_blog/assets/js/3.28069a0d.js"><link rel="prefetch" href="/learning_blog/assets/js/4.5e7fb7ae.js"><link rel="prefetch" href="/learning_blog/assets/js/5.37bbb6e5.js"><link rel="prefetch" href="/learning_blog/assets/js/6.adfa8de6.js"><link rel="prefetch" href="/learning_blog/assets/js/7.75144e26.js"><link rel="prefetch" href="/learning_blog/assets/js/8.2ad448e8.js"><link rel="prefetch" href="/learning_blog/assets/js/9.691c2ab5.js">
    <link rel="stylesheet" href="/learning_blog/assets/css/0.styles.292e88f6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/learning_blog/" class="router-link-active home-link"><img src="/learning_blog/logo.png" alt="一兜小白菜" class="logo"> <span class="site-name">一兜小白菜</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/learning_blog/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-submenu-selected"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          Java Learning
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/learning_blog/go/">
          Go Learning
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/learning_blog/spring/">
          Spring Learning
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/learning_blog/architect/">
          软件架构师
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/learning_blog/java/jvm/" aria-current="page" title="JVM learning" class="sidebar-link">JVM learning</a></li><li><a href="/learning_blog/java/jvm/线程.html" title="线程" class="sidebar-link">线程</a></li><li><a href="/learning_blog/java/jvm/JVM 内存区域.html" title="JVM 内存区域" class="sidebar-link">JVM 内存区域</a></li><li><a href="/learning_blog/java/jvm/JVM 运行时内存.html" title="JVM 运行时内存" class="sidebar-link">JVM 运行时内存</a></li><li><a href="/learning_blog/java/jvm/垃圾回收与算法.html" title="垃圾回收与算法" class="sidebar-link">垃圾回收与算法</a></li><li><a href="/learning_blog/java/jvm/Java 四种引用类型.html" title="Java 四种引用类型" class="sidebar-link">Java 四种引用类型</a></li><li><a href="/learning_blog/java/jvm/GC 分代收集算法 VS 分区收集算法.html" title="GC 分代收集算法 VS 分区收集算法" class="sidebar-link">GC 分代收集算法 VS 分区收集算法</a></li><li><a href="/learning_blog/java/jvm/GC 垃圾收集器.html" title="GC 垃圾收集器" class="sidebar-link">GC 垃圾收集器</a></li><li><a href="/learning_blog/java/jvm/Java IO&amp;NIO.html" title="Java IO/NIO" class="active sidebar-link">Java IO/NIO</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning_blog/java/jvm/Java IO&amp;NIO.html#io-模型" title="IO 模型" class="sidebar-link">IO 模型</a></li><li class="sidebar-sub-header"><a href="/learning_blog/java/jvm/Java IO&amp;NIO.html#java-nio" title="Java NIO" class="sidebar-link">Java NIO</a></li><li class="sidebar-sub-header"><a href="/learning_blog/java/jvm/Java IO&amp;NIO.html#channel" title="Channel" class="sidebar-link">Channel</a></li><li class="sidebar-sub-header"><a href="/learning_blog/java/jvm/Java IO&amp;NIO.html#buffer" title="Buffer" class="sidebar-link">Buffer</a></li><li class="sidebar-sub-header"><a href="/learning_blog/java/jvm/Java IO&amp;NIO.html#selector" title="Selector" class="sidebar-link">Selector</a></li></ul></li><li><a href="/learning_blog/java/jvm/JVM 类加载机制.html" title="JVM 类加载机制" class="sidebar-link">JVM 类加载机制</a></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="java-io-nio"><a href="#java-io-nio" class="header-anchor">#</a> Java IO/NIO</h1> <h2 id="io-模型"><a href="#io-模型" class="header-anchor">#</a> IO 模型</h2> <img src="/learning_blog/img/java/jvm/Java IO包.png" alt="Java IO包"> <h3 id="阻塞-io-模型"><a href="#阻塞-io-模型" class="header-anchor">#</a> 阻塞 IO 模型</h3> <p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才会接触 block 状态。典型的阻塞 IO 模型的例子：</p> <div class="language-java extra-class"><pre class="language-java"><code>data <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果数据没有就绪，那么就会一直阻塞在 read() 方法。</p> <h3 id="非阻塞-io-模型"><a href="#非阻塞-io-模型" class="header-anchor">#</a> 非阻塞 IO 模型</h3> <p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个 error 时，就表示数据还没有准备好，于是可以再次发起 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么就会立马将数据拷贝到用户线程，并返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞 IO 模型不会交出 CPU 资源，而是会一直占用 CPU。典型的非阻塞 IO 模型如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token operator">!=</span> error<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 处理数据</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于非阻塞 IO 模型有一个很严重的问题，<font color="#93D172">在 while 循环中需要不断地去询问内核数据是否就绪，这样就会导致 CPU 占用率特别高</font>，因此一般情况下很少利用 while 循环配合非阻塞 IO 模型一起使用。</p> <h3 id="多路复用-io-模型"><a href="#多路复用-io-模型" class="header-anchor">#</a> 多路复用 IO 模型</h3> <p>多路复用 IO 模型是目前使用得比较多得模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO 模型中，会<font color="#0172D0">有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作</font>。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select() 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。</p> <p><font color="#93D172">另外多路复用 IO 为何比非阻塞 IO 模型的效率高，是因为在非阻塞 IO 中，不断地轮询 socket 状态是通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比使用用户线程要高的多</font>。</p> <p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，<font color="#0172D0">一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询</font>。</p> <h3 id="信号驱动-io-模型"><a href="#信号驱动-io-模型" class="header-anchor">#</a> 信号驱动 IO 模型</h3> <p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接受到信息之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p> <h3 id="异步-io-模型"><a href="#异步-io-模型" class="header-anchor">#</a> 异步 IO 模型</h3> <p>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何的 block。内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。整个过程中，用户线程完全不需要知道整个 IO 操作是如何进行的，<font color="#0172D0">只需要先发起一个请求，当接收内核返回成功信号时，表示 IO 操作已经完成，可以直接去使用数据了</font>。</p> <p>在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经准备就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。</p> <p><font color="#FF0632">注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO</font></p> <h2 id="java-nio"><a href="#java-nio" class="header-anchor">#</a> Java NIO</h2> <p>NIO 主要有三大核心部分：Channel（通道），Buffer（缓冲区），Selector。传统 IO 基于字节流和字符流进行操作，<font color="#93D172">而 NIO 基于 Channel 和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中</font>。Selector（选择区）用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程就可以监听多个数据通道。</p> <img src="/learning_blog/img/java/jvm/Java NIO网络模型.png" alt="Java NIO网络模型"> <p>NIO 和传统 IO 之间第一个最大的区别就是，<font color="#93D172">IO 是面向流的，NIO 是面向缓冲区的</font>。</p> <img src="/learning_blog/img/java/jvm/Java NIO包.png" alt="Java NIO包"> <h3 id="nio-的缓冲区"><a href="#nio-的缓冲区" class="header-anchor">#</a> NIO 的缓冲区</h3> <p>Java IO 面向流意味着每次从流中读取一个或多个字节，直至读取所有字节，他们没有被缓存在任何地方。此外，他不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同，他先将数据读取到一个它稍后处理的缓冲区中，需要时可在缓冲区中前后移动操作数据。这增加了数据处理过程中的灵活性。但是，在使用前要检查该缓冲区中是否包含所有你需要处理的数据。并且，需要确保当更多的数据读入缓冲区时，不要覆盖缓冲区中尚未被处理的数据。</p> <h3 id="nio-的非阻塞"><a href="#nio-的非阻塞" class="header-anchor">#</a> NIO 的非阻塞</h3> <p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有数据被读取，或是数据完全写入。该线程在此期间不能再干任何事情了。NIO 的非阻塞模式，让一个线程从某通道发送请求读取数据，但是只能获取到当前通道中可用数据，如果目前没有数据可以使用，就什么都不会获取。而不是保持线程阻塞，所以在数据变的可以读取使用之前，该线程任然可以继续做其它的事情。非阻塞写也是如此的。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。<font color="#93D172">线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程可以管理多个输入和输出通道（Channel）</font>。</p> <h2 id="channel"><a href="#channel" class="header-anchor">#</a> Channel</h2> <p>Channel 和 IO 中的 Stream（流）是差不多一个等级的。<font color="#93D172">只不过 Stream 是单向的</font>，譬如：InputStream、OutputStream，<font color="#93D172">而 Channel 是双向的</font>，既可以用来进行读操作，又可以用来进行写操作。</p> <p>NIO 中的 Channel 的主要实现有：</p> <ol><li>FileChannel</li> <li>DatagramChannel</li> <li>SocketChannel</li> <li>ServerSocketChannel</li></ol> <p>这里看名字就可以知道这些实现类的作用，分别对应文件IO、UDP和TCP（Server 和 Client）。</p> <h2 id="buffer"><a href="#buffer" class="header-anchor">#</a> Buffer</h2> <p>Buffer，顾名思义，<font color="#93D172">缓冲区，实际上是一个容器，是一个连续数组</font>。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p> <img src="/learning_blog/img/java/jvm/缓冲区数据流向.png" alt="缓冲区数据流向"> <p>上面的图描述了从一个客户端向服务器发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入到通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。</p> <p>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：ByteBuffer、IntBuffer、CharBuffer、LongBuffer、DoubleBuffer、FloatBuffer、ShortBuffer。</p> <h2 id="selector"><a href="#selector" class="header-anchor">#</a> Selector</h2> <p>Selector 类是 NIO 的核心类，<font color="#93D172">Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理</font>。这样一来，只用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/learning_blog/java/jvm/GC 垃圾收集器.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        GC 垃圾收集器
      </a></span> <span class="next"><a href="/learning_blog/java/jvm/JVM 类加载机制.html">
        JVM 类加载机制
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/learning_blog/assets/js/app.a4dcdc72.js" defer></script><script src="/learning_blog/assets/js/2.15fb6e89.js" defer></script><script src="/learning_blog/assets/js/17.5e4e5795.js" defer></script>
  </body>
</html>