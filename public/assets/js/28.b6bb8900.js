(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{756:function(t,a,r){"use strict";r.r(a);var e=r(105),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"java-四种引用类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-四种引用类型"}},[t._v("#")]),t._v(" Java 四种引用类型")]),t._v(" "),r("h2",{attrs:{id:"强引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强引用"}},[t._v("#")]),t._v(" 强引用")]),t._v(" "),r("p",[t._v("在 Java 中最常见的就是强引用，"),r("font",{attrs:{color:"#0172D0"}},[t._v("把一个对象赋值给一个变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时")]),t._v("，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。")],1),t._v(" "),r("h2",{attrs:{id:"软引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#软引用"}},[t._v("#")]),t._v(" 软引用")]),t._v(" "),r("p",[r("font",{attrs:{color:"#0172D0"}},[t._v("软引用需要用 SoftReference 类来实现")]),t._v("，对于只有软引用的对象来说，当系统内存足够时他不会被回收，当系统内存空间不足时它会被回收。软引用通常用在内存敏感的程序中。")],1),t._v(" "),r("h2",{attrs:{id:"弱引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弱引用"}},[t._v("#")]),t._v(" 弱引用")]),t._v(" "),r("p",[r("font",{attrs:{color:"#0172D0"}},[t._v("弱引用需要用 WeakReference 类来实现")]),t._v("，他比软引用的生存周期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象的内存。")],1),t._v(" "),r("h2",{attrs:{id:"虚引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚引用"}},[t._v("#")]),t._v(" 虚引用")]),t._v(" "),r("p",[t._v("虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。"),r("font",{attrs:{color:"#0172D0"}},[t._v("虚引用的主要作用是跟踪对象被垃圾回收的状态")]),t._v("。")],1)])}),[],!1,null,null,null);a.default=s.exports}}]);