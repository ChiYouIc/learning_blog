(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{744:function(t,a,v){"use strict";v.r(a);var e=v(105),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),v("p",[t._v("这里所说的线程指的是程序执行过程中的一个线程实体。JVM 允许一个应用执行多个线程。Hostpot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。"),v("font",{attrs:{color:"red"}},[t._v("当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统的原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把他们分配到任何可用的 CPU 资源上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法，当线程结束时，就释放原生线程和 Java 线程的所有资源。")])],1),t._v(" "),v("p",[t._v("Hotspot JVM 后台运行的系统线程主要有下面几个：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("系统线程")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("虚拟机线程（VM Thread）")]),t._v(" "),v("td",[t._v("这个线程等待 JVM 到达安全点操作才会启动。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the-world 垃圾回收、线程dump、线程暂停、线程偏向锁（biased locking）接触。")])]),t._v(" "),v("tr",[v("td",[t._v("周期性任务线程")]),t._v(" "),v("td",[t._v("该线程主要负责定时器事件（中断），用来调度周期性操作的执行。")])]),t._v(" "),v("tr",[v("td",[t._v("GC 线程")]),t._v(" "),v("td",[t._v("这些线程支持 JVM 中不同的垃圾回收活动。")])]),t._v(" "),v("tr",[v("td",[t._v("编译器线程")]),t._v(" "),v("td",[t._v("这些线程在运行时将字节码动态编译成本地平台相关的机器码。")])]),t._v(" "),v("tr",[v("td",[t._v("信号分发线程")]),t._v(" "),v("td",[t._v("这个线程接收发送到 JVM 的信息并调用适当的 JVM 方法处理。")])])])]),t._v(" "),v("blockquote",[v("h2",{attrs:{id:"什么是-jvm-安全点-safe-point"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-jvm-安全点-safe-point"}},[t._v("#")]),t._v(" 什么是 JVM 安全点（Safe Point）")]),t._v(" "),v("p",[t._v("程序在执行时并非所有地方都能停顿下来开始 GC，只有在特定位置停顿下来才能开始 GC，即垃圾回收；这些特定的位置就称之为“安全点（Safe Point）”。")]),t._v(" "),v("h2",{attrs:{id:"安全点的选择"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全点的选择"}},[t._v("#")]),t._v(" 安全点的选择")]),t._v(" "),v("p",[t._v("安全点的选择很重要，如果安全点选择太少，会导致 GC 等待事件太长；过多会导致系统负荷变大，性能降低。由于大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为安全点（Safe Point），如：")]),t._v(" "),v("ul",[v("li",[t._v("循环的末尾")]),t._v(" "),v("li",[t._v("方法临近返回前")]),t._v(" "),v("li",[t._v("调用方法之后")]),t._v(" "),v("li",[t._v("抛出异常的位置")])]),t._v(" "),v("h2",{attrs:{id:"gc-线程的终端策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc-线程的终端策略"}},[t._v("#")]),t._v(" GC 线程的终端策略")]),t._v(" "),v("p",[t._v("当 GC 发生时，我们应该如何检测所有的线程都跑到了最近的安全点停顿下来了呢？")]),t._v(" "),v("ul",[v("li",[t._v("抢先式中断（目前没有虚拟机再采用该策略了）：中断所有线程，当有线程不在安全点，就恢复线程，让线程跑到安全点。")]),t._v(" "),v("li",[t._v("主动式中断：设置一个中断标志，各个线程运行到安全点的时候就主动轮询这个标志，如果中断标志为 true，则将自己当前线程进行中断挂起。（举例：客栈（安全点）门上安装了一个显示器，上面会显示 true，或者 false；当系统需要进行垃圾回收的时候，将更新显示 true，此时就是告诉线程进入客栈之后就不要出来了。）")])]),t._v(" "),v("h2",{attrs:{id:"安全区域-safe-region"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全区域-safe-region"}},[t._v("#")]),t._v(" 安全区域 Safe Region")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Safe Point 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safe Point。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。")])]),t._v(" "),v("li",[v("p",[t._v("安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safe Point。")])])]),t._v(" "),v("h2",{attrs:{id:"安全区域-safe-region-执行流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全区域-safe-region-执行流程"}},[t._v("#")]),t._v(" 安全区域 Safe Region 执行流程")]),t._v(" "),v("p",[t._v("实际执行时：")]),t._v(" "),v("ol",[v("li",[t._v("当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Point，如果这段时间内发生 GC，JVM 会忽略表示为 Safe Region 状态的线程（即认为该线程是安全的）")]),t._v(" "),v("li",[t._v("当线程即将离开时，会检查 JVM 是否已经完成了 GC，如果完成，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止。")])]),t._v(" "),v("p",[t._v("摘抄自：https://blog.csdn.net/fsjwin/article/details/109235471")])])])}),[],!1,null,null,null);a.default=_.exports}}]);