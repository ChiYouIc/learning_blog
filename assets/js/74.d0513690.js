(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{615:function(t,o,r){"use strict";r.r(o);var v=r(4),_=Object(v.a)({},(function(){var t=this,o=t.$createElement,r=t._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"分代收集算法"}},[t._v("分代收集算法")]),t._v(" "),r("p",[t._v("当前主流 VM 垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法会根据对象存活周期的不同将内存划分为几块，如 JVM 中的"),r("font",{attrs:{color:"#0172D0"}},[t._v("新生代、老年代、永久代")]),t._v("，这样就可以根据各年代特点分别采用最适当的 GC 算法。")],1),t._v(" "),r("h3",{attrs:{id:"在新生代-复制算法"}},[t._v("在新生代-复制算法")]),t._v(" "),r("p",[t._v("每次垃圾收集都能发现大批量对象已死，只有少量存活。因此选用"),r("font",{attrs:{color:"#0172D0"}},[t._v("复制算法")]),t._v("，只需要付出少量存活对象的复制成本就可以完成收集。")],1),t._v(" "),r("h3",{attrs:{id:"在老年代-标记整理算法"}},[t._v("在老年代-标记整理算法")]),t._v(" "),r("p",[t._v("因为对象在老年代存活率高、没有额外空间对它进行分担担保，就必须采用"),r("font",{attrs:{color:"#0172D0"}},[t._v("“标记-清理”")]),t._v("或"),r("font",{attrs:{color:"#0172D0"}},[t._v("“标记-整理”")]),t._v("算法来进行回收，不必进行内存复制，且直接腾出空闲内存。")],1),t._v(" "),r("h2",{attrs:{id:"分区收集算法"}},[t._v("分区收集算法")]),t._v(" "),r("p",[r("font",{attrs:{color:"#0172D0"}},[t._v("分区算法则将整个空间划分为连续的不同小区间，每个小区间独立使用")]),t._v("，独立回收。这样做的好处是"),r("font",{attrs:{color:"#0172D0"}},[t._v("可以控制一次回收多少个小区间")]),t._v("，根据目标停顿时间，每次合理地回收若干个小区间（而不是整个堆），从而减少一次 GC 所产生的停顿。")],1)])}),[],!1,null,null,null);o.default=_.exports}}]);