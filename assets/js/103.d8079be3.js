(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{641:function(t,r,s){"use strict";s.r(r);var n=s(4),a=Object(n.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"start"}},[t._v("start()")]),t._v(" "),s("p",[s("strong",[t._v("start() 方法是用来启动线程，真正实现多线程运行")]),t._v("。当调用 start() 方法后线程将从 "),s("code",[t._v("NEW（新建）状态")]),t._v(" 变为 "),s("code",[t._v("READY（就绪）状态")]),t._v("。只有当线程成为 "),s("code",[t._v("READY（就绪）状态")]),t._v("时，他才可能得到 CPU 的调度，执行线程任务，也就是线程从 "),s("code",[t._v("READY（就绪）状态")]),t._v(" 到 "),s("code",[t._v("RUNABLE（执行）状态")]),t._v(" 的转换。 start() 方法是启动线程，但不是立即执行线程。")]),t._v(" "),s("h2",{attrs:{id:"run"}},[t._v("run()")]),t._v(" "),s("p",[t._v("run() 方法是线程执行体，也就是我们需要线程执行的任务区域；将需要执行的任务代码编写到 run() 方法中，当线程得到 CPU 调度之后，run() 就会被执行。run() 方法和 start() 方法的关系是："),s("code",[t._v("start() 负责将线程从新建状态调入就绪状态，run() 则是线程在执行状态下需要执行的任务")]),t._v("。")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/img/java/thread/start()与run().png"),alt:"start()与run()"}})])}),[],!1,null,null,null);r.default=a.exports}}]);