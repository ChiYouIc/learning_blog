(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{579:function(v,_,t){"use strict";t.r(_);var i=t(4),l=Object(i.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"熔断和限流怎么做"}},[v._v("熔断和限流怎么做？")]),v._v(" "),t("h3",{attrs:{id:"熔断"}},[v._v("熔断")]),v._v(" "),t("p",[v._v("在分布式应用中为了防止服务之间调用过程中出现异常，所导致整体链路故障，需要对服务应用进行熔断降级处理。熔断即在存在问题时，暂时切断内部调用，避免局部不稳定因素导致整个分布式系统的雪崩。熔断降级作为保护服务自身的手段，通常是在客户端进行规则配置和熔断识别的。")]),v._v(" "),t("h4",{attrs:{id:"三种熔断降级措施"}},[v._v("三种熔断降级措施：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("慢调用比例策略")])]),v._v(" "),t("p",[v._v("在所设定的时间窗口内，慢调用的比例大于所设置的阈值，则对接下来访问的请求进行自动熔断。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("错误比例策略")])]),v._v(" "),t("p",[v._v("在所设定的时间窗口内，调用的访问错误比例大于所设置的阈值，则对接下来访问的请求进行自动熔断。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("错误计数策略")])]),v._v(" "),t("p",[v._v("在所设定的时间窗口内，调用的访问错误次数大于所设置的阈值，则对接下来访问的请求进行自动熔断。")])])]),v._v(" "),t("h3",{attrs:{id:"限流"}},[v._v("限流")]),v._v(" "),t("p",[v._v("在分布式系统架构中，为了防止接口流量的突发性暴增导致整个服务雪崩的现象，需要对服务接口进行流量控制，防止接口流量超出系统预期承受范围。")]),v._v(" "),t("h4",{attrs:{id:"两种流程控制方式"}},[v._v("两种流程控制方式：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("基于 QPS")])]),v._v(" "),t("p",[v._v("最常用的流量控制方式是基于 QPS 来做的，在一定的时间窗口范围内按照特定的规则达到所设定的阈值则进行流量调控。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("基于并发隔离")])]),v._v(" "),t("p",[v._v("基于资源访问的并发协程数来控制对资源的访问数量，主要是控制对资源访问的最大协程数，避免因为资源的异常导致协程耗尽。")])])]),v._v(" "),t("h2",{attrs:{id:"一致性哈希表"}},[v._v("一致性哈希表")]),v._v(" "),t("p",[v._v("一致性哈希表是分布式哈希表的一种，一致性哈希表的思想：通过给系统中的每个节点分配一个随机 Token，这些 Token 构成一个哈希环。在执行数据存放操作时，先计算 key 的哈希值，然后按顺时针方向，将其存放在第一个大于等于该 key 哈希值的 Token 所在的节点上。这样一来，新增或减少节点只会影响到相邻节点，对其他节点不会产生影响，所以只会又部分的 key 失效。提高了系统的扩展性，也使得系统能够更好的适应数据的快速增长。")]),v._v(" "),t("h2",{attrs:{id:"缓存雪崩、缓存穿透、缓存击穿-各自的解决办法"}},[v._v("缓存雪崩、缓存穿透、缓存击穿，各自的解决办法")]),v._v(" "),t("h3",{attrs:{id:"缓存处理流程"}},[v._v("缓存处理流程：")]),v._v(" "),t("p",[v._v("前台请求，后端先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。")]),v._v(" "),t("h3",{attrs:{id:"缓存穿透"}},[v._v("缓存穿透：")]),v._v(" "),t("p",[v._v("缓存穿透是指缓存和数据库中都没有目标数据，而用户不断发起请求获取不存在的数据，这时的用户很可能是攻击者，改类攻击会导致数据库压力过大。")]),v._v(" "),t("h4",{attrs:{id:"解决方案"}},[v._v("解决方案：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("接口层增加校验，如果用户鉴权、id 做基础校验，id <= 0 的直接拦截；")])]),v._v(" "),t("li",[t("p",[v._v("从缓存中取不到的数据，在数据库中也没有取到，这时也可以将 key – value 对写为 key – null，缓存有效时间可以设置短点，如 30 秒。这样可以防止攻击用户反复用同一个 id 暴力攻击。")])])]),v._v(" "),t("h3",{attrs:{id:"缓存击穿"}},[v._v("缓存击穿")]),v._v(" "),t("p",[v._v("缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库取数据，引起数据库压力瞬间增大，造成数据库负载。")]),v._v(" "),t("h4",{attrs:{id:"解决方案-2"}},[v._v("解决方案：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("设置热点数据永远不过期；")])]),v._v(" "),t("li",[t("p",[v._v("在取数据库的过程中，在数据库操作中加上互斥锁。")])])]),v._v(" "),t("h3",{attrs:{id:"缓存雪崩"}},[v._v("缓存雪崩")]),v._v(" "),t("p",[v._v("缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿是并发获取同一数据，缓存雪崩是很多不同的数据在缓存中过期，导致都去数据库中查询数据。")]),v._v(" "),t("h4",{attrs:{id:"解决方案-3"}},[v._v("解决方案：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生；")])]),v._v(" "),t("li",[t("p",[v._v("如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中；")])]),v._v(" "),t("li",[t("p",[v._v("设置热点数据永不过期。")])])]),v._v(" "),t("h2",{attrs:{id:"kafka-消息积压问题"}},[v._v("Kafka 消息积压问题")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("实时/消费任务挂掉导致的消费滞后；")])]),v._v(" "),t("li",[t("p",[v._v("Kafka 分区少了；")])]),v._v(" "),t("li",[t("p",[v._v("由于Kafka消息 key 设置的不合理，导致分区数据不均衡。")])])])])}),[],!1,null,null,null);_.default=l.exports}}]);