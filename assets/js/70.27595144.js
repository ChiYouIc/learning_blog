(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{607:function(t,v,_){"use strict";_.r(v);var a=_(4),l=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"java-语言具有哪些特点"}},[t._v("Java 语言具有哪些特点？")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("面向对象")])]),t._v(" "),_("p",[t._v("面向对象是指以对象为基本粒度，其下包含属性和方法。对象的说明用属性表达，而通过使用方法来操作这个对象。面向对象技术使得应用程序的开发变得简单易用，节省代码。Java是一种面向对象的语言，也继承了面向对象的诸多好处，如代码扩展、代码复用等。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("跨平台性")])]),t._v(" "),_("p",[t._v("所谓的跨平台性，是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。这是软件发展的趋势和编程人员追求的目标。之所以这样说，是因为计算机硬件的种类繁多，操作系统也各不相同，不同的用户和公司有自己不同的计算机环境偏好，而软件为了能在这些不同的环境里正常运行，就需要独立于这些平台。而在Java语言中， Java自带的虚拟机很好地实现了跨平台性。 Java源程序代码经过编译后生成二进制的字节码是与平台无关的，但是可被Java虚拟机识别的一种机器码指令。 Java虚拟机提供了一个字节码到底层硬件平台及操作系统的屏障，使得Java语言具备跨平台性。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("安全性")])]),t._v(" "),_("p",[t._v("安全性可以分为四个层面，即语言级安全性、编译时安全性、运行时安全性、可执行代码安全性。语言级安全性指Java的数据结构是完整的对象，这些封装过的数据类型具有安全性。编译时要进行Java语言和语义的检查，保证每个变量对应一个相应的值，编译后生成Java类。运行时Java类需要类加载器载入，并经由字节码校验器校验之后才可以运行。 Java类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("多线程")])]),t._v(" "),_("p",[t._v("多线程在操作系统中已得到了最成功的应用。多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。 Java除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("简单易用")])]),t._v(" "),_("p",[t._v("Java源代码的书写不拘泥于特定的环境，可以用记事本、文本编辑器等编辑软件来实现，然后将源文件进行编译，编译通过后可直接运行，通过调试则可得到想要的结果。")])])]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/jkzr/p/10701233.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击此处查看原文"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"面向对象的四个特征"}},[t._v("面向对象的四个特征？")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("抽象")])]),t._v(" "),_("p",[t._v("抽象就是忽略一个主题中与当前目标无关的那些方面，以便充分地体现与当前目标相关的方面。（就是把现实世界中的某一类东西，以取出来，用程序代码表示，抽象的结果一般叫做类或者接口。）抽象并不包含目标的所有方面，而只是选择其中的一部分，隐藏暂时不用的部分。抽象包括两个方面，一是数据抽象，二是过程抽象。")]),t._v(" "),_("ul",[_("li",[t._v("数据抽象：用代码的形式表示现实世界中一类事物的特性，就是针对对象的属性。比如建立一个鸟这样的类，鸟都有以下属性：一对翅膀、两只脚、羽毛等。抽象出来的类都是鸟的属性，或者成员变量。")]),t._v(" "),_("li",[t._v("过程抽象：用代码形式表示现实世界中事物的一系列行为，就是针对对象的行为特征。比如鸟会飞、会叫等。抽象出来的类一般都是鸟的方法。")])])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("继承")])]),t._v(" "),_("p",[t._v("继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需求。因此可以说，继承是为了重用父类代码，同时为实现多态性作准备。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("封装")])]),t._v(" "),_("p",[t._v("封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封闭的对象，这些对象通过一个受保护的接口访问其他对象。封装隐藏了类的内部实现机制，从而可以在不影响使用者的前提下改变类的内部结构，同时保护了数据。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("多态性")])]),t._v(" "),_("p",[t._v("多态性是指允许不同的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。总的来说，方法的重写、重载与动态链接构成多态性。Java 引入多态的概念原因之一就是弥补类的单继承带来的功能不足。（为了规避 C++ 中多继承造成的复杂继承问题，Java 采用单继承。）")]),t._v(" "),_("p",[_("strong",[t._v("动态链接")]),t._v("：对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态链接。")]),t._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"title"},[t._v("注意")]),_("p",[_("strong",[t._v("继承与重载")]),t._v("：一是子类与父类的关系，二是重载方法的调用问题。")])]),_("p",[t._v("子类对象可以直接当成父类对象使用，但反过来就不可以。举例来说，人是父类，学生是人的子类，所以学生对象一定具备人对象的属性，但是人对象就未必具有学生对象的特性。所以学生对象可以当做人对象来使用，但是人对象就不能当做学生对象使用。注意当把子类对象当成父类对象使用时，子类对象将失去所有的子类特性，只保留与父类同名的属性和方法（同名方法不仅是函数名相同，而且参数类型也要一样，否则不予保留）。此时可以对父类方法进行重写。")]),t._v(" "),_("p",[t._v("一个类中如果定义了重载的方法，则系统在调用方法时，会根据参数的类型自动选择调用合适的方法。")])])]),t._v(" "),_("p",[_("a",{attrs:{href:"http://blog.sciencenet.cn/blog-469621-379622.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击此处查看原文"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"字节序定义"}},[t._v("字节序定义？")]),t._v(" "),_("p",[t._v("字节序是指多字节数据在计算机内存中存储或网络传输时各字节的存储顺序。通常由小端和大端两组方式。")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("小端：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。")])]),t._v(" "),_("li",[_("p",[t._v("大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。")])])]),t._v(" "),_("p",[t._v("Java语言的字节序是大端。")]),t._v(" "),_("h2",{attrs:{id:"jdk-与-jre-有什么区别"}},[t._v("JDK 与 JRE 有什么区别？")]),t._v(" "),_("p",[t._v("JRE：Java Runtime Environment（Java 运行时环境）。即 Java 程序的运行时环境，包括了 Java 虚拟机，Java 基础类库。")]),t._v(" "),_("p",[t._v("JDK：Java Development Kit（Java 开发工具包）。即 Java 语言编写的程序所需的开发工具包。JDK 包含了 JRE，同时还包括 Java 源码的编译器 javac、监控工具 jconsole、分析工具 jvisualvm。")]),t._v(" "),_("h2",{attrs:{id:"java-访问修饰符"}},[t._v("Java 访问修饰符")]),t._v(" "),_("p",[t._v("Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("default")]),t._v(" (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。")]),t._v(" "),_("li",[_("strong",[t._v("private")]),t._v(" : 在同一类内可见。使用对象：变量、方法。 "),_("strong",[t._v("注意：不能修饰类（外部类）")])]),t._v(" "),_("li",[_("strong",[t._v("public")]),t._v(" : 对所有类可见。使用对象：类、接口、变量、方法")]),t._v(" "),_("li",[_("strong",[t._v("protected")]),t._v(" : 对同一包内的类和所有子类可见。使用对象：变量、方法。 "),_("strong",[t._v("注意：不能修饰类（外部类）")]),t._v("。")])]),t._v(" "),_("p",[t._v("我们可以通过以下表来说明访问权限：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("修饰符")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("当前类")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("同一包内")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("子孙类(同一包)")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("子孙类(不同包)")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("其他包")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[t._v("public")])]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[t._v("protected")])]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y/N（"),_("a",{attrs:{href:"https://www.runoob.com/java/java-modifier-types.html#protected-desc",target:"_blank",rel:"noopener noreferrer"}},[t._v("说明"),_("OutboundLink")],1),t._v("）")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[t._v("default")])]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[_("code",[t._v("private")])]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("Y")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("N")])])])]),t._v(" "),_("h2",{attrs:{id:"构造方法、成员变量初始化以及静态成员变量三者的初始化顺序"}},[t._v("构造方法、成员变量初始化以及静态成员变量三者的初始化顺序")]),t._v(" "),_("p",[t._v("先后顺序：静态成员变量 -> 成员变量 -> 构造方法。")]),t._v(" "),_("p",[t._v("详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。")]),t._v(" "),_("h2",{attrs:{id:"接口和抽象类的相同点和区别"}},[t._v("接口和抽象类的相同点和区别")]),t._v(" "),_("p",[t._v("相同点：")]),t._v(" "),_("ul",[_("li",[t._v("接口与抽象类都不可被实例化。")]),t._v(" "),_("li",[t._v("接口的实现类或抽象类的子类需要分别实现接口与抽象类中对应的方法后才能被实例化。")])]),t._v(" "),_("p",[t._v("不同点：")]),t._v(" "),_("ul",[_("li",[t._v("接口只能定义方法，不能有方法的实现（1.8 以前是这样子的，1.8 之后可以使用 default 关键字修饰方法，可对方法做默认实现），而抽象类可以有方法的定义与实现。")]),t._v(" "),_("li",[t._v("实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但是只能继承一个抽象类。")]),t._v(" "),_("li",[t._v("当子类和父类之间存在逻辑上的层次结构时，推荐使用抽象类，有利于功能的累积。如果只是希望定义两个或更多的对象空间的交互定义时，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后的维护和扩展。")]),t._v(" "),_("li",[t._v("接口中声明的变量都是 public static final 修饰的，不存在一般成员变量，而抽象类可以不存在这类限制。")]),t._v(" "),_("li",[t._v("接口中的方法必须是 public 的，不能存在 protected 或者 private。")])]),t._v(" "),_("h2",{attrs:{id:"为什么-java-语言不支持多继承"}},[t._v("为什么 Java 语言不支持多继承？")]),t._v(" "),_("ul",[_("li",[t._v("为了使程序的结构更加清晰，便于维护。我们假设 Java 支持多继承，现有 A 继承类 B、C，类 B、C 中都定义了一个方法 say()，那么我们在使用类 A 的实例化对象调用 say() 时，会发生什么情况呢？这就使得 say() 在类 A 中产生了"),_("strong",[t._v("二义性")]),t._v("。但是如果 B、C 都是接口，就不会产生这种情况，因为对于类 A 来说，它是必须要自己重新实现 say() 的，就不会产生二义性，即使调用时的引用类型是 B 或者 C。")]),t._v(" "),_("li",[t._v("多继承还会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。")])]),t._v(" "),_("h2",{attrs:{id:"java-提供的多态机制"}},[t._v("Java 提供的多态机制")]),t._v(" "),_("p",[t._v("Java 提供了两种用于多态的机制，分别是重载与重写。")]),t._v(" "),_("ul",[_("li",[t._v("重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。")]),t._v(" "),_("li",[t._v("重写：重写是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。")])]),t._v(" "),_("h2",{attrs:{id:"重载与重写的区别"}},[t._v("重载与重写的区别")]),t._v(" "),_("ul",[_("li",[t._v("重写发生在父子类关系之间，是垂直关系；重载是同一类方法之间的关系，是水平关系；")]),t._v(" "),_("li",[t._v("重写只能由一个方法或一对方法产生关系；重载是多个方法之间的关系；")]),t._v(" "),_("li",[t._v("重写要求方法命、参数列表完全一致；重载要求方法名一致，参数列表不一致；")]),t._v(" "),_("li",[t._v("重写调用方法时，具体的执行的方法体是由对象的引用类型来决定的，而重载是根据调用时实参表与形参表对应选择方法体；")]),t._v(" "),_("li",[t._v("重载方法可以改变返回值的类型，重写方法是不能改变返回值类型的。")])]),t._v(" "),_("h2",{attrs:{id:"final、finally-和-finalize-的区别是什么"}},[t._v("final、finally 和 finalize 的区别是什么？")])])}),[],!1,null,null,null);v.default=l.exports}}]);