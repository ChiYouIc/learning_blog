(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{649:function(t,a,e){"use strict";e.r(a);var s=e(4),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，\n如果线程数量超过了线程池的最大容量，那么超出数量的线程将会进行排队等待，等待其它线程执行完毕，再从\n任务队列中取出任务来执行。它的主要特定是："),e("code",[t._v("线程服用、控制最大并发数和管理线程")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"线程复用"}},[t._v("线程复用")]),t._v(" "),e("p",[t._v("每一个 Thread 的类都有一个 start 方法。当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。那么\n该类的 run() 方法中就是调用 Runnable 对象的 run() 方法。"),e("code",[t._v("如果继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象")]),t._v("。\n这就是线程池的实现原理，"),e("code",[t._v("循环方法中不断获取 Runnable 是用 Queue 实现的")]),t._v("，在获取下一个 Runnable 之前可以是阻塞的。")]),t._v(" "),e("h2",{attrs:{id:"线程池的组成"}},[t._v("线程池的组成")]),t._v(" "),e("p",[t._v("一般的线程池主要分为以下 4 个组成部分：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("线程池管理器：用于创建并管理线程池")])]),t._v(" "),e("li",[e("p",[t._v("工作线程：线程池中的线程")])]),t._v(" "),e("li",[e("p",[t._v("任务接口：每个任务必须实现的接口，用于工作线程调度其运行")])]),t._v(" "),e("li",[e("p",[t._v("任务队列：用于存放待处理的任务，提供一种缓冲机制")])])]),t._v(" "),e("p",[t._v("Java 中的线程池是通过 Executor 架构实现的，该架构中用到了 "),e("code",[t._v("Executor")]),t._v("、"),e("code",[t._v("Executors")]),t._v("、"),e("code",[t._v("ExecutorService")]),t._v("、"),e("code",[t._v("ThreadPoolExecutor")]),t._v("、"),e("code",[t._v("Callable")]),t._v(" 和 "),e("code",[t._v("Future")]),t._v("、"),e("code",[t._v("FutureTask")]),t._v(" 这些类。")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/img/java/thread/线程池UML.png"),alt:"线程池UML"}}),t._v(" "),e("p",[t._v("ThreadPoolExecutor 的构造方法如下：")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadPoolExecutor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" corePoolSize"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" maximumPoolSize"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" keepAliveTime"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TimeUnit")]),t._v(" unit"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BlockingQueue")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" workQueue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadFactory")]),t._v(" threadFactory"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                          "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RejectedExecutionHandler")]),t._v(" handler"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"},[t._v("参数详解")]),e("ul",[e("li",[e("p",[t._v("corePoolSize：指定了线程池中的线程数量；")])]),t._v(" "),e("li",[e("p",[t._v("maximumPoolSize：指定了线程池中的最大线程数量；")])]),t._v(" "),e("li",[e("p",[t._v("keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁；")])]),t._v(" "),e("li",[e("p",[t._v("unit： keepAliveTime 的单位；")])]),t._v(" "),e("li",[e("p",[t._v("workQueue：任务队列，被提交但尚未被执行的任务；")])]),t._v(" "),e("li",[e("p",[t._v("threadFactory：线程工厂，用于创建线程，一般用默认的即可；")])]),t._v(" "),e("li",[e("p",[t._v("handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。")])])])]),e("h2",{attrs:{id:"拒绝策略"}},[t._v("拒绝策略")]),t._v(" "),e("p",[t._v("当线程池中的线程已经到达了阈值，无法继续为新任务服务，同时，等待队列也排满了，再也塞不下新任务了。这时就需要使用拒绝策略机制来处理这个问题。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"},[t._v("JDK 内置的拒绝策略如下：")]),e("ul",[e("li",[e("p",[t._v("AbortPolicy：直接抛出异常，阻止系统正常运行；")])]),t._v(" "),e("li",[e("p",[t._v("CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但极有可能导致任务提交线程的性能会急剧下降；")])]),t._v(" "),e("li",[e("p",[t._v("DiscardOldestPolicy：丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务；")])]),t._v(" "),e("li",[e("p",[t._v("DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理。如果任务丢失，这是最好的一种方案。")])])])]),e("p",[t._v("上述的内置拒绝策略均实现了 "),e("code",[t._v("RejectedExecutionHandler")]),t._v(" 接口，若已上策略仍然无法满足实际需要，完全可以自己扩展 "),e("code",[t._v("RejectedExecutionHandler")]),t._v(" 接口，该接口的定义如下：")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RejectedExecutionHandler")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("rejectedExecution")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),t._v(" r"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadPoolExecutor")]),t._v(" executor"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"线程池工作过程"}},[t._v("线程池工作过程")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("线程池刚创建时，里面没有一个线程。任务队列是最为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。")])]),t._v(" "),e("li",[e("p",[t._v("当调用 execute() 方法添加一个任务时，线程池会做如下判断：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("如果正在运行的线程数量小于 "),e("code",[t._v("corePoolSize")]),t._v("，那么马上创建线程运行这个任务；")])]),t._v(" "),e("li",[e("p",[t._v("如果正在运行的线程数量大于或等于 "),e("code",[t._v("corePoolSize")]),t._v("，那么将这个任务放入对待队列；")])]),t._v(" "),e("li",[e("p",[t._v("如果等待队列已满，而且正在运行的线程数量小于 "),e("code",[t._v("maximumPoolSize")]),t._v("，那么还是要创建非核心线程立刻运行这个任务；")])]),t._v(" "),e("li",[e("p",[t._v("如果等待队列已满，而且正在运行的线程数量大于或等于 "),e("code",[t._v("maximumPoolSize")]),t._v("，那么线程池会抛出异常 "),e("code",[t._v("RejectExecutionException")]),t._v("。")])])])]),t._v(" "),e("li",[e("p",[t._v("当一个线程完成任务时，它会从队列中取下一个任务来执行。")])]),t._v(" "),e("li",[e("p",[t._v("当一个线程无事可做，超过一定的时间（"),e("code",[t._v("keepAliveTime")]),t._v("）后，线程池会判断，如果当前运行的线程数大于 "),e("code",[t._v("corePoolSize")]),t._v("，那么这个线程就被停掉。\n所以在线程池的所有任务完成之后，它最终会收缩到 "),e("code",[t._v("corePoolSize")]),t._v(" 大小。")])])]),t._v(" "),e("h3",{attrs:{id:"示意图"}},[t._v("示意图")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/img/java/thread/线程池工作流程.png"),alt:"线程池工作流程"}})])}),[],!1,null,null,null);a.default=n.exports}}]);