(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{614:function(v,t,a){"use strict";a.r(t);var r=a(4),_=Object(r.a)({},(function(){var v=this,t=v.$createElement,a=v._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("img",{attrs:{src:v.$withBase("/img/java/jvm/JVM GC.png"),alt:"VM GC"}}),v._v(" "),a("h2",{attrs:{id:"如何确定垃圾"}},[v._v("如何确定垃圾")]),v._v(" "),a("h3",{attrs:{id:"引用计数法"}},[v._v("引用计数法")]),v._v(" "),a("p",[v._v("在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单的说，即一个"),a("font",{attrs:{color:"#0172D0"}},[v._v("对象如果没有任何与之关联的引用，即他们的引用计数都为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象")]),v._v("。")],1),v._v(" "),a("h3",{attrs:{id:"可达性分析"}},[v._v("可达性分析")]),v._v(" "),a("p",[v._v("为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC Roots”对象作为起点搜索。如果"),a("font",{attrs:{color:"#0172D0"}},[v._v("在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的")]),v._v("。需要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。")],1),v._v(" "),a("h2",{attrs:{id:"标记清除算法-mark-sweep"}},[v._v("标记清除算法（Mark-Sweep）")]),v._v(" "),a("p",[v._v("最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间，如图：")]),v._v(" "),a("img",{attrs:{src:v.$withBase("/img/java/jvm/标记清除算法示例图.png"),alt:"标记清除算法示例图"}}),v._v(" "),a("p",[v._v("从图中我们就可以发现，该算法"),a("font",{attrs:{color:"#0172D0"}},[v._v("最大的问题是内存碎片化严重")]),v._v("，后续可能发生大对象不能找到可利用空间的问题。")],1),v._v(" "),a("h2",{attrs:{id:"复制算法-copying"}},[v._v("复制算法（Copying）")]),v._v(" "),a("p",[v._v("为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只能使用其中一块，当这一块内存存满后将尚存活的对象复制到另一块上去，把已经使用的内存清掉，如图：")]),v._v(" "),a("img",{attrs:{src:v.$withBase("/img/java/jvm/复制算法示例图.png"),alt:"复制算法示例图"}}),v._v(" "),a("p",[v._v("这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原来的一半。且存活对象增多的话，Copying 算法的效率会大大降低。")]),v._v(" "),a("h2",{attrs:{id:"标记整理算法-mark-compact"}},[v._v("标记整理算法（Mark-Compact）")]),v._v(" "),a("p",[v._v("结合了已上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，"),a("font",{attrs:{color:"#0172D0"}},[v._v("标记后不是清理对象，而是将存活对象移向内存的一端")]),v._v("。然后清除端边界外的对象。如图：")],1),v._v(" "),a("img",{attrs:{src:v.$withBase("/img/java/jvm/标记整理算法示例图.png"),alt:"标记整理算法示例图"}}),v._v(" "),a("h2",{attrs:{id:"分代收集算法"}},[v._v("分代收集算法")]),v._v(" "),a("p",[v._v("分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老年代（Tenured/Old Generation）和新生代（Young Generation）。"),a("font",{attrs:{color:"red"}},[v._v("老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法")]),v._v("。")],1),v._v(" "),a("h3",{attrs:{id:"新生代与复制算法"}},[v._v("新生代与复制算法")]),v._v(" "),a("p",[v._v("目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1 : 1 来划分新生代。一般将新生代划分为一块比较大的 Eden 空间和两个比较小的 Survivor 空间（From Survivor，To Survivor），每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。")]),v._v(" "),a("img",{attrs:{src:v.$withBase("/img/java/jvm/新生代内存.png"),alt:"新生代内存"}}),v._v(" "),a("h3",{attrs:{id:"老年代与标记复制算法"}},[v._v("老年代与标记复制算法")]),v._v(" "),a("p",[v._v("而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。")]),v._v(" "),a("ol",[a("li",[v._v("Java 虚拟机提到过的处于方法区的永生代（Permanent Generation），它用来存储 Class 类，常量，方法描述等。对于永生代的回收主要包括废弃常量和无用的类。")]),v._v(" "),a("li",[v._v("对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space（Survivor 当前存放对象的那一块），少数情况会直接分配到老年代。")]),v._v(" "),a("li",[v._v("当新生代的 Eden Space 和 From Space 空间不足时，就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。")]),v._v(" "),a("li",[v._v("如果 To Space 无法足够存储某个对象，则将这个对象存储到老年代。")]),v._v(" "),a("li",[v._v("再进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。")]),v._v(" "),a("li",[v._v("当对象在 Survivor 区躲过一次 GC 后，其年龄就会 +1。"),a("font",{attrs:{color:"#0172D0"}},[v._v("默认情况下年龄到达 15 的对象就会被转移到老年代中")]),v._v("。")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);