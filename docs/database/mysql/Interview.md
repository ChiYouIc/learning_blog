---
title: MySQL 面试
sidebar: auto
date: 2021-08-12
categories:
 - 数据库
tags:
 - MySQL
 - 面试
---



## 三大范式

**第一范式**：字段具有原子性，不可再分（字段单一职责）

**第二范式**：满足第一范式，每行应该被唯一区分，加一列存放每行的唯一标识符，称为主键（都要依赖主键）

**第三范式**：满足第一、第二范式，且一个表不能包含其它表已存在的非主键信息（不间接依赖，不存在其它表的非主键信息）



**范式优点与缺点**

优点：范式化，重复冗余数据少，更新快，修改少，查询时更少得 distinct。

缺点：因为一个表不存在冗余重复数据，**查询可能会造成很多关联**，效率变低，**可能使一些索引策略无效**，范式化将列存在不同得表中，这些列若能在同一个表中可以是一个索引。



## InnoDB 与 MyISAM 的区别



### MyISAM 与 InnoDB 的区别

- InnoDB 是聚簇索引，MyISAM 是非聚簇索引
- InnoDB 数据与索引一起保存在 `.ibd` 中，MyISAM 表结构存储在 `.frm`，索引存在 `.myi`，数据存在 `.myd` 
- InnoDB 支持事务、外键、行锁和表锁，MyISAM 不支持事务、外键，只支持表锁
- InnoDB 更新更优，MyISAM 查询更优
- 索引都是采用的 B+Tree 索引
- MyISAM 支持全文索引，InnoDB 5.6 版本以前不支持，之后的版本才开始支持全文索引



### MyISAM

- 支持事务，但是每次查询都是原子的
- 支持表级锁，每次操作会对整张表加锁
- 存储表的总行数
- 一个 MyISAM 表由三个文件组成，表结构 `.frm`、索引 `.myi`、数据 `.myd`
- 采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。



### InnoDB

- 支持 ACID 事务，支持四种隔离级别
- 支持行级锁及外键约束，因此支持写并发
- 不存储总行数
- 主键索引采用聚簇索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查询数据，需要先通过辅索引得到数据主键，再访问主索引（回表），最好使用自增主键，防止插入数据时，为维持 B+Tree 树结构时，文件的大调整。



### 使用场景

大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的（不过，前提是你的项目不介意这样）。

MyISAM 不支持事务、崩溃恢复等缺点（这些都是比较敏感缺陷）。

- MyISAM 适合读多更新少的：MyISAM 索引与数据是分开放的，因此有读取快的说法。
- InnoDB 适合插入更新频繁的：索引与数据一起放，建立索引更复杂，使用行锁，对于频繁更新操作效率更高。

**总结**：MyISAM 查询更优，InnoDB 更新更优。

**MyISAM 适合读多，更新少的场景**。MyISAM 使用非聚簇索引，数据和索引分开存的，而 InnoDB 数据和索引存在一起；数据量大时，一个内存页大小固定，读进内存的数据 MyISAM 就多一点（数据量小看不出差距，数据量大时差距就明显了）。因为 MyISAM 只把索引指针读进内存，可以存更多索引，所以查询速度也就更快，而 InnoDB 还需要维护其它数据，比如其它的隐藏字段 row_id、tx_id 等。



## 自增主键的理解

### 自增主键

InnoDB 引擎的自增值，其实是**保存在内存中**的，并且到了 MySQl 8.0 版本以后，才有了**“自增持久化”**的能力，也就是才实现了**“如果发生了重启，表的自增值可以恢复为 MySQL 重启前的值”**。

- 在 MySQL 5.7 及以前的版本，**自增值保存在内存里**，并没有持久化。每次重启后，第一次打开表的时候，都会去查找**自增值的最大值**。max(id)，然后将 max(id) + 1 作为这个表当前的自增值。

  ::: tip

  举例来说，如果一个表当前数据行里最大的id是10，AUTO_INCREMENT=11。这时候，我们删除id=10的行，AUTO_INCREMENT还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。

  :::

- 在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启前的值。



### 自增值修改机制

- 如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段。
- 如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。



### 自增值新增机制

- 如果准备插入的值 >= 当前自增值，新的自增值就是 **“准备插入的值 + 1”**；
- 否则，自增值不变。



## 为什么自增主键不连续

- 在 MySQL 5.7 及之前的版本，自增值保存在内存里，没有持久化

- **「事务回滚」**（自增值不能回滚，因为并发插入数据时，回退自增值 ID 可能会造成主键冲突）

- 唯一键冲突（由于表的自增值已变，但是主键发生冲突没有插入数据，下一次插入主键=现在变了的自增值 + 1，所以不连续）

  ::: tip

  假设，表t里面已经有了(1,1,1)这条记录，这时我再执行一条插入数据命令：

  ``` sql
  insert into t values(null, 1, 1); (自增id,唯一键c,普通字段d)
  ```

  这个语句的执行流程就是：

  1. 执行器调用InnoDB引擎接口写入一行，传入的这一行的值是(0,1,1);
  2. InnoDB发现用户没有指定自增id的值，获取表t当前的自增值2；
  3. 将传入的行的值改成(2,1,1);
  4. 将表的自增值改成3；
  5. 继续执行插入数据操作，由于已经存在c=1的记录，所以报Duplicate key error，语句返回。

  这个表的自增值改成3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键c冲突，所以id=2这一行并没有插入成功，但也没有将自增值再改回去。

  所以，在这之后，再插入新的数据行时，拿到的自增id就是3。**「也就是说，出现了自增主键不连续的情况」**。

  :::



## InnoDB 为什么推荐用自增ID

- 主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费

- 新插入的行一定会在原有的最大数据行下一行，MySQL 定位和寻址很快，不会为计算新行的位置而做出额外的消费

- 减少了页分裂和碎片的产生

  **「UUID」**：**「大量的随机IO」**+**「页分裂导致移动大量的数据」**+ 数据会有碎片

**总结**：自增 ID 有序，会按照顺序往最后插入，而 UUID 无序，随机生成，随机插入，会造成频繁的页分裂，内存碎片化，产生大量的随机 IO。



## 什么是索引

- 排好序的数据结构，可以帮助快速查找数据
- 优缺点：索引可以提高查询速度，查询使用优化隐藏器提高性能，但是也会占据物理空间，降低增删改的速度，因为还要操作索引文件。



### 索引类型（覆盖索引 + 回表 + 索引下推 + 联合索引）

**「普通索引」**：可以重复

**「唯一索引」**：唯一，可为空，表中只有一个主键索引，可有多个唯一索引

**「主键索引」**

- ​	唯一，不为空，叶子节点存储行数据记录，主键索引也称为聚簇索引，对应非主键索引的叶子节点存的主键的值（二级索引），用二级索引查需要回表操作（根据二级索引查到主键，再根据主键去主键索引查询）。
- 一般推荐用自增主键，**保证空间利用率，减少页分裂**。

**「全文索引」**

----

**「覆盖索引」**：索引字段覆盖了查询语句涉及的字段，直接通过索引文件就可以返回查询所需的数据，不必通过回表操作。

**「回表」**：通过索引找到主键，再根据主键 ID 去查询所需数据。

**「索引下推」**：在根据索引查询过程中就根据查询条件过滤掉一些记录，减少最后的回表操作。

**「联合索引」**：组合索引（最左前缀原则）



## 索引底层数据结构



## 什么是 B 树？

B 树（Balance Tree）和 B+ 树都可以认为是 m 叉的多路平衡树查找树，但是从理论上讲，二叉树查找速度和比较次数都是最小的，那为什么在数据库索引应用中不采用二叉树呢？

因为我们需要考虑到磁盘 IO 的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存中，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少 IO 次数，对于树来说，IO 次数就是树的高度，而”胖矮“就是 B树的特征之一，它的每个节点最多包含 m 个孩子，m 称为 b 树的阶，m 的大小取决于磁盘页的大小。

- 一个 m 阶的 B 树具有如下几个特征：
  - 定义任意非叶子结点最多只有M个儿子，且M>2；
  - 根结点的儿子数为[2, M]；
  - 除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；
  - 非叶子结点的关键字个数=儿子数-1；
  - 所有叶子结点位于同一层；
  - k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。

- B 树的一些特征
  - 关键字集合分布在整颗树中；
  - 任何一个关键字出现且只出现在一个结点中；
  - 搜索有可能在非叶子结点结束；
  - 其搜索性能等价于在关键字全集内做一次二分查找。



## 什么是 B+ 树？

B+树，是 B树 的一种变体，查询性能更好。m阶的 B+ 树的特征：

- 有 n棵子树的非叶子结点中含有 n 个关键字（B树 是 n-1 个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（B树是每个关键字都保存数据）。
- 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依靠关键字的大小自小而大顺序连接。
- 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
- 通常在 B+ 树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
- 同一个数字会在不同节点中重复出现，根节点的最大元素就是 B+ 树的最大元素。



## B+ 树相比于 B 树的查询优势

- B+ 树的中间节点不存储数据，所以磁盘页能容纳更多的节点元素，更”胖矮“；
- B+ 树查询必须查找到叶子节点，B 树只要匹配到即可不用管元素位置，因此 B+ 树查找更稳定（稳定不代表慢）；
- 对于范围查询来说，B+ 树只需要遍历叶子节点链表即可，B树却需要重复地中序遍历。



## 索引的设计原则（查询快，占用空间少）

- 出现在 where 子句或则连接子句中的字段可作为索引字段
- 基数小的表没必要建立索引
- 使用短索引，如果索引
