# 线程基本方法

> 线程相关的基本方法有 `wait`、`notify`、`notifyAll`、`sleep`、`join`、`yield` 等。

<img :src="$withBase('/img/java/thread/线程数据流图.png')" alt="线程数据流图">

## 线程等待（wait）

调用该方法的线程进入 `WAITING` 状态，只有等待其它线程的通知活被中断才会返回，需要注意的是调用 wait() 方法后，会释放对象的锁。
因此，wait 方法一般用在同步方法或同步代码块中。

## 线程睡眠（sleep）

sleep 导致当前线程休眠，于 wait 方法不同的是 `sleep 不会释放当前占有的锁`，sleep(long) 会导致线程进入 `TIMED-WAITING` 状态，而 `wait() 方法会导致当前线程进入 WAITING 状态`。

## 线程让步（yield）

yield 会使当前线程`让出 CPU 执行时间片`，与其它线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。

## 线程中断（interrupt）

中断一个线程，其本意是`给这个线程一个通知信号，影响这个线程内部的一个中断标志位。这个线程本身并不会因此而改变状态（如阻塞、终止等）`。

1. `调用 interrupt() 方法并不会中断一个正在运行的线程`。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。

2. 若调用 sleep() 而使线程处于 TIMED-WAITING 状态，这时调用 interrupt() 方法，会抛出 InterruptException，从而使线程提前结束 TIMED-WAITING 状态。

3. 许多声明抛出 InterruptException 的方法（如 Thread.sleep(long mills)方法），抛出异常前，都会清除中断标志位，所以抛出异常后，调用 isInterrupted() 方法将会返回 false。

4. 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如，你想终止一个线程 thread 的时候，可以调用 thread.interrupt() 方法，在线程的 run 方法内部可以根据 `thread.isInterrupted() 的值来优雅的终止线程`。

## join 等待其它线程终止

`join() 方法，等待其它线程终止`。在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，等待另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 CPU 调度。

::: tip
### 为什么要用 join() 方法？
很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。
:::

## 线程唤醒（notify）

Object 类中的 notify() 方法，`唤醒在此对象监视器上等待的单个线程`，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是随机的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，
在对象的监视器上等待，`直到当前的线程放弃此对象上的锁，才能继续执行被唤醒的线程`，被唤醒的线程将以常规方式与在该对象上主动同步的其它线程进行锁竞争。类似的方法还有 notifyAll()，唤醒在监视器上等待的所有线程。

## 其它方法

1. sleep()：强迫一个线程睡眠 N 毫秒；

2. isAlive()：判断一个线程是否存货；

3. join()：等待线程终止；

4. activeCount()：程序中活跃的线程数；

5. enumerate()：枚举程序中的线程；

6. currentThread()：得到当前线程；

7. isDaemon()：一个线程是否为守护线程；

8. setDaemon()：设置一个线程为守护线程（用户线程和守护线程的区别在于，是否等待主线程，是否随主线程结束而结束）；

9. setName()：为线程设置一个名称；

10. wait()：强迫一个线程等待；

11. notify()：通知一个线程继续运行；

12. setPriority()：设置一个线程的优先级；

13. getPriority()：获得一个线程的优先级。
